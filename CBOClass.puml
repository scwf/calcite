@startuml

interface RelNode
abstract AbstractRelNode

RelNode <|-- AbstractRelNode
AbstractRelNode <|-- RelSubset
RelSubset *-- RelSet
VolcanoPlanner o-- RelSubset
VolcanoPlanner o-- RelNode

class RelSubset {
*初始生成是每个relnode生成一个RelSubset
RelOptCost bestCost
RelSet set
RelNode best
RelNode getBest()
void computeBestCost(RelOptPlanner planner)
}

class RelSet {
List<RelNode> rels
List<RelNode> parents
List<RelSubset> subsets
RelSet equivalentSet
RelNode rel
void addInternal(RelNode rel)
}

class VolcanoPlanner {
  RelSubset root
  RelNode originalRoot
  Set<RelOptRule> ruleSet
  IdentityHashMap<RelNode, RelSubset> mapRel2Subset
  RelOptCostFactory costFactory
  RuleQueue ruleQueue
  List<RelTraitDef> traitDefs

  boolean addRule(RelOptRule rule)
  void setRoot(RelNode rel)
  RelNode findBestExp()
}

class CBO {
  凡是不一定能提升性能的rule都应该划到cbo中去考虑
  1. 逻辑计划之间的转换
  2. ensure requirement
  3. 逻辑计划转物理计划
}

Table <|-- ScannableTable
Table <|-- FilterableTable
Table <|-- ScannableTable
Schema <|-- AbstractSchema

interface Table {
  奇怪，居然不是继承自RelNode
  RelDataType getRowType(RelDataTypeFactory typeFactory);
  Statistic getStatistic();
  Schema.TableType getJdbcTableType();
}
interface ScannableTable {
 Enumerable<Object[]> scan(DataContext root)
}
interface FilterableTable {
Enumerable<Object[]> scan(DataContext root, List<RexNode> filters)
}

interface Schema {
Table getTable(String name)
Collection<Function> getFunctions(String name)
Schema getSubSchema(String name)
}

class AbstractSchema {
Map<String, Table> getTableMap()
}

Node <|-- TableScanNode
Node <|-- JoinNode
Node <|-- ProjectNode
interface Node {
void run()
}
class TableScanNode {
}
class JoinNode {
}
class ProjectNode {
}


class CSVExecution {
按如下顺序
CalciteMetaImpl.prepareAndExecute
CalciteConnectionImpl.parseQuery
CalcitePrepareImpl.prepareSql
CalcitePrepareImpl.prepare_
CalcitePrepareImpl.prepare2_
Prepare.prepareSql
convertQuery:547, SqlToRelConverter (org.apache.calcite.sql2rel)
validate:587, SqlValidatorImpl (org.apache.calcite.sql.validate)
validateScopedExpression:877, SqlValidatorImpl (org.apache.calcite.sql.validate)
validate:220, SqlSelect (org.apache.calcite.sql)
validateQuery:902, SqlValidatorImpl (org.apache.calcite.sql.validate)
validateNamespace:921, SqlValidatorImpl (org.apache.calcite.sql.validate) [1]
validate:84, AbstractNamespace (org.apache.calcite.sql.validate) [1]
validateImpl:60, SelectNamespace (org.apache.calcite.sql.validate)
validateSelect:3136, SqlValidatorImpl (org.apache.calcite.sql.validate)
validateFrom:2894, SqlValidatorImpl (org.apache.calcite.sql.validate) [1]
validateQuery:902, SqlValidatorImpl (org.apache.calcite.sql.validate) [2]
validateNamespace:921, SqlValidatorImpl (org.apache.calcite.sql.validate) [2]
validate:84, AbstractNamespace (org.apache.calcite.sql.validate) [2]
validateImpl:171, IdentifierNamespace (org.apache.calcite.sql.validate)
resolveImpl:108, IdentifierNamespace (org.apache.calcite.sql.validate)
resolveTable:202, DelegatingScope (org.apache.calcite.sql.validate)
resolveTable:98, EmptyScope (org.apache.calcite.sql.validate)
resolve_:142, EmptyScope (org.apache.calcite.sql.validate)
getTable:220, CalciteSchema (org.apache.calcite.jdbc)
getImplicitTable:111, CachingCalciteSchema (org.apache.calcite.jdbc)
get:232, CachingCalciteSchema$AbstractCached (org.apache.calcite.jdbc)
build:57, CachingCalciteSchema$2 (org.apache.calcite.jdbc)
build:60, CachingCalciteSchema$2 (org.apache.calcite.jdbc)
getTableNames:87, AbstractSchema (org.apache.calcite.schema.impl)
getTableMap:71, CsvSchema (org.apache.calcite.adapter.csv)
}

@enduml